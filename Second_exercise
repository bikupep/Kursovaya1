import random
import time

def custom_sort(arr: list[int]) -> list[int]:
    """
    Пользовательская (неоптимизированная) сортировка с использованием опорного элемента.
    
    Алгоритм:
    - Если массив пустой или состоит из одного элемента, он уже считается отсортированным.
    - Выбирается опорный элемент из середины массива.
    - Элементы меньше опорного перемещаются в начало, а элементы больше опорного - в конец.
    - Рекурсивно сортируются левая и правая части массива.

    :param arr: Список целых чисел для сортировки.
    :return: Отсортированный список.
    """
    if len(arr) <= 1:  # Базовый случай: массив длиной 0 или 1 считается отсортированным
        return arr

    # Выбор опорного элемента из середины массива
    pivot: int = arr.pop(len(arr) // 2)  # Удаляем и сохраняем опорный элемент
    new_arr: list[int] = [pivot]  # Новый массив, начинающийся с опорного элемента

    # Распределение элементов относительно опорного
    for i in arr:
        if i > pivot:
            new_arr.append(i)  # Элементы больше опорного добавляются в конец
        else:
            new_arr.insert(0, i)  # Элементы меньше опорного добавляются в начало

    # Найдем индекс опорного элемента для разделения массива
    separate: int = find_from_end(new_arr, pivot)
    left: list[int] = new_arr[:separate]  # Левая часть
    right: list[int] = new_arr[separate:]  # Правая часть

    # Рекурсивно сортируем левую и правую части и соединяем их
    return custom_sort(left) + custom_sort(right)

def find_from_end(arr: list[int], value: int) -> int:
    """
    Функция поиска элемента в списке с конца.
    
    :param arr: Список, в котором осуществляется поиск.
    :param value: Искомый элемент.
    :return: Индекс элемента, найденного с конца.
    
    Предполагается, что элемент всегда присутствует в списке.
    """
    for i in range(len(arr) - 1, -1, -1):
        if arr[i] == value:
            return i

test1 = [random.randint(0, 100) for _ in range(10000)]  # Генерация случайного массива на 10000 элементов

start = time.time()  # Замер времени перед сортировкой
custom_sort(test1)  # Выполнение сортировки
end = time.time()  # Замер времени после сортировки
print(f'Время сортировки рандомного массива: {end - start:.5f} секунд')

# Тест для массива, отсортированного в обратном порядке
test2 = [i for i in range(10000, 0, -1)]  # Создаем массив от 10000 до 1
start = time.time()
custom_sort(test2)
end = time.time()
print(f'Время сортировки массива отсортированного в обратном порядке: {end - start:.5f} секунд')

def improved_quicksort(arr: list[int]) -> list[int]:
    """
    Оптимизированная версия быстрой сортировки.
    
    Улучшения:
    - Деление элементов на три части:
      * Элементы меньше опорного
      * Элементы, равные опорному
      * Элементы больше опорного
    
    :param arr: Список целых чисел для сортировки.
    :return: Отсортированный список.
    """
    if len(arr) <= 1:  # Базовый случай: массив длиной 0 или 1 считается отсортированным
        return arr
    
    pivot: int = arr[len(arr) // 2]  # Выбор опорного элемента
    left = [x for x in arr if x < pivot]  # Элементы меньше опорного
    middle = [x for x in arr if x == pivot]  # Элементы, равные опорному
    right = [x for x in arr if x > pivot]  # Элементы больше опорного

    # Рекурсивно сортируем и объединяем результаты
    return improved_quicksort(left) + middle + improved_quicksort(right)

test1 = [random.randint(0, 100) for _ in range(10000)]  # Генерация случайного массива
start = time.time()
improved_quicksort(test1)
end = time.time()
print(f'Время сортировки рандомного массива: {end - start:.5f} секунд')

test2 = [i for i in range(10000, 0, -1)]  # Массив, отсортированный в обратном порядке
start = time.time()
improved_quicksort(test2)
end = time.time()
print(f'Время сортировки массива отсортированного в обратном порядке: {end - start:.5f} секунд')
